# Wiring up a Todo application using Circus and React


Circus helps you keep your application pure by dividing your logic it into declarative. An application is divid

The core idea of a circuit is to sequence data from one component to another. A large circuit with many components will retain this sequential behaviour through each and every component connection. Then, by ensuring that components are purely functional, we can completely separate the concerns of circuitry and component operation, providing us with an opportunity to scale up the complexity of the former without unduly complicating the performance and design of the latter.

A Circus app consists of a logic into two distinct groups

The circuit requirements for a Todo app are relatively simple. let's start by listing off the kinds of components that we might expect to see:

* a component that collects new Todo items
* a component that adds new items to the current list
* a component that displays the current list of Todo items
* a component that determines the current state of the list
* a component that filters the display list

circuit -> | { descrition } -> { item: newItem } -> &
           | { list } ->                            & -> addNewItem -> { list }
                      -> displayList -> id

key:    |  = merge (take any)
        &  = join  (take all)
        {} = channel
        + =
        Â± = pulse

circuit = merge({
    description,
    list: list.feed()
})

I'm going to flesh out just enough to run the application with one feature - adding a new Todo item. So for now we are going to ignore the filtering and list state functionality.

We might easily imagine the kind of data that needs to travel between these components but we don't need to be too specific. We really only need to identify the input and the output channels of our components before joining them up to complete a circuit.

* new Todo expects a text and returns a new Todo
* add new item expects a list and a Todo and returns a new list
* display list expects a list and returns a formatted list

Time to build out some rudimentary components. Since these are destined for a circuit, they need to comply with the Circus functor signature: v -> v. That is, a component receives a value, performs some mapping function and returns a new value. When two or more channel inputs are required, they will be passed in as properties on the input value. Fortunately ES2015 destructuring makes this a painless operation.

```
const newTodo = description => ({ description, completed: false })

const addNewItem = {list, item} => list.slice().push({id: list.length, ...item}) // destructured v.list, v.item

const displayList = Circus.id() // output ?? just return identity for now

```

All of these components are pure functions which makes them easy to test and substitute. We still need to answer the output questions hovering over the display component but we have enough code to complete the circuit. Specifically, we have identified the input and output channels of the circuit so now we can start to join them up. But how?

## Introducing signals
### (and how they join up components and channels to make circuits)

A signal is a monadic value that changes over time. This means that the value, and any operations performed on it, are all wrapped by the signal. The monadic pattern allows operations to be chained; each operation returns a new monadic signal value

```
signal().map(op1).map(op2) // => signal
```

Signal operations - our components - are 'lifted' into the signal through a mapping functor (called map) and are executed whenever the value changes. Each operation returns a new value wrapped in a signal.

```
// our component lifted into a signal..
signal().map(newTodo).value('write Todo doc') // => { description: 'write Todo doc', completed: false }
```

When a signal accepts input, the new value flows through all of the components mapped by the signal. Or more precisely, the new value flows into the first component. The value generated by that component flows into the next component, and so on. the flow functor makes this easy to express

```
const inc = v => v + 1
const sqr = v => v * v
signal().map(inc).map(sqr).value(1) // same as...
signal().flow(inc,sqr).value(1) // => 4
```

Signals can accept values from the outside world. User input, program state, other signals - all valid signal inputs. Signals also accept inputs from a circuit through a mechanism called channel binding. A signal bound to a circuit through a channel will receive an input value directly from the circuit. The signal output value is also bound to the circuit, either through its own binding or defaulting to the input binding. Thus a signal represents a data channel between a circuit and its components.

A circuit is a set of signals connected by at least one channel

Circuits are also signals in their own right, extended with binding semantics, but otherwise behaving exactly the same as any other signal.

```
const signal1 = Circus.map(inc)
const signal2 = Circus.map(sqr)

const circuit1 = Circus.join({
    channel1: signal1,
    channel2: signal2
})

circuit1.value({channel1: 2, channel2: 4}) // {channel1: 3, channel2: 16}

// ES2015 shorthand comes in handy when the channel and the signal have the same binding name
const circuit2 = Circus.join( { signal1, signal2 }).value({ signal1: 123 })
```

## A circuit is born

So far we have not explicitly defined any channels, we have simply matched the component input requirements to the idea of channels. By explicitly defining our channel requirements, we will be joining the signals that wrap our components together into a circuit.

```
require Circus from 'circus'

// signal channels
const list = Circus.signal()
const item = Circus.map(newTodo).pulse()

Circus.join({ list, item }).map({ list: addNewItem })
Circus.join({ list }).map(displayList)

// the completed circuit with two exposed channels
const circuit = Circus.merge({ item, list })
```

The circuit is complete but effectively switched off. To activate or test the circuit we can push values onto one or more of its channels.

```
// start off with an empty list and add an item
circuit.value({ list [], item: 'task1' })
list.value() // { description: 'task1', completed: false }
```

## wiring it all together
The display component is still empty. How do we add this functionality to the circuit now that it is complete? One way would be to go back and redefine the components at source. For a simple Todo application this might be the sensible option. But what if we want to maintain a separation between the circuit and the rest of the application? This is really the main point of circuits - the separation of declarative structural logic from imperative component logic.

Our circuit contains everything needed to accept and store Todo items. Two channels are exposed as entry points: list and item. We have already tested this circuitry, so now all we need to do is bind it to an event emitter - an input onChange event will do nicely, and that of course will be deeply nested in a React component.

```
import circuit from './circuit'
import { value } from 'react-circus-bindings'

const { item, list } = circuit.channels

const Todo = todo => <li>
    {todo.description}
</li>

const TodoList = params => render(
    <div>
        <h1>TODOs</h1>
        <input placeholder="What do you want to do?" onChange={value(item)}/>
        <ul>
            {params.list.map(todo => <Todo key={todo.id} {...todo}/>)}
        </ul>
    </div>,
    document.querySelector('#app')
)

// lift the view into the circuit
circuit.list.map(TodoList)

// and bootstrap it with an empty list
list.value([])
```

The application needs more functionality: each list item should be editable. The following code demonstrates a complete Todo application

```
// /circuit.js

// components
const newTodo = description => ({ description, completed: false })
const addNewItem = {list, item} => list.slice().push({id: list.length, ...item})
const displayList = {list} => Circus.id() // output ?? just return identity for now
const determineState = {list} => { total: list.length, completed: list.filter( item => item.completed ).length}
const filterList = {list, flag} => list.filter( item => item.completed === flag )
const replaceInList = { list, todo } => list.map(t => t.id===todo.id? todo : t)
const removeFromList = { list, todo } => list.filter(t => t.id!==todo.id)

// circuit
const flag = signal()
const list = signal()
const item = Circus.map(newTodo)
const state = Circus.join({ list }).map(determineState)
const addTodo = Circus.join({ list, item }).map(addNewItem)
const updateView = Circus.join({ list, flag, state }).map(filterList).map(displayList)
const completeTodo = Circus.map().join({ list }).map(replaceInList)
const circuit = Circus.join({ list, flag, item })
```

```
// todo.jsx

import circuit from './circuit'
import { value, checked } from 'react-circus-bindings'

const Todo = todo => <li>
  <input type="checkbox" checked={todo.completed} onClick={checked(completeTodo)} />
  <input className={todo.completed} value={todo.description} onChange={value(editTodo)} />
  <input type="checkbox" onClick={checked(deleteTodo)} />
</li>

const TodoState = {state, flag} => <footer>
  <button onClick={checked(flag==='all')}>all</button>
  <button onClick={checked(flag==='completed')}>completed</button>
  <button onClick={checked(flag==='notCompleted')}>notCompleted</button>
  <div>Total: {state.total} Completed: {state.completed}</div>
</footer>

const TodoList = params => render(
    <div>
        <h1>TODOs</h1>
        <input placeholder="What do you want to do?" onChange={value(circuit.item)}/>
        <ul>
            {params.list.map(todo => <Todo
                key={todo.id}
                completeTodo={circuit.completeTodo}
                editTodo={circuit.editTodo}
                deleteTodo={circuit.deleteTodo}
                {...todo}
            />)}
        </ul>
        <TodoState {...params}/>
    </div>,
    document.querySelector('#app')
)

circuit.displayList.map(TodoList)
```