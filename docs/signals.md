# Introducing signals
## (and how they join up components and channels to make circuits)

A signal is a monadic value that changes over time. This means that the value, and any operations performed on it, are all wrapped by the signal. The monadic pattern allows operations to be chained; each operation returning the same signal with a new state value:

```
signal().map(op1).map(op2) // => signal
```

Signal operations are 'lifted' into the signal through a mapping operator (called map) and are executed whenever a value is bound to the signal. Each operation returns a new value wrapped in a signal.

```
const inc = v => v + 1
const sqr = v => v * v

signal().map(inc).map(sqr).value(1) // => 4

```

When a value is bound to the signal (the signal accepts input), the new value flows through all of the components lifted into the signal. Or more precisely, the new value flows into the first component. The value generated by that component flows into the next component, and so on. This is such a common pattern that Signal provides a flow operator that makes this easy to express, but it is just syntactic sugar for a series of maps:

```
signal().flow(inc,sqr).value(1)     // => 4
```

Signals can accept values from the outside world. User input, program state, other signals - all valid signal inputs. Signals also accept inputs from a circuit through a mechanism called channel binding. A signal bound to a circuit through a channel will receive an input value directly from the circuit. The signal output value is also bound to the circuit, either through its own binding or defaulting to the input binding. Thus a signal represents a data channel between a circuit and its components.

## Channels
A channel is a pair of input and output signals that share common state. Channels provide a clear distinction between circuit inputs and circuit outputs so that, for example, a circuit's inputs can be bound to a user input form (the view), and its outputs mapped over a set of functional components (the model). The processing path between inputs and outputs defines the application's intent and might include such functional concepts as validation, animation and data shaping, as well as providing the facility for additional circuit routing when inputs are related in some way.

```
const outputA = signalA.channel(Circus.after)  // signalA assumes input state, or...
const outputB = signalB.channel()              // ...default channel is output
const inputB  = signalB.channel(Circus.before) // signalA assumes output state
```

A circuit is a signal with one or more channels. Circuit channels are formed when signals are joined or merged with object syntax, or when signals are joined or merged with existing channels.

```
const signal1 = Circus.map(inc)
const signal2 = Circus.map(sqr)

const circuit1 = Circus.join({
    signal1,
    signal2
})

circuit1.value({signal1: 2, signal2: 4}) // {signal1: 3, signal2: 16}
```
