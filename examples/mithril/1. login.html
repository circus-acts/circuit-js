<html>
<head>
<style>
  label {display:block; width:200px;text-align: right;}
  span,input {margin:5px;}
</style>
<script src="../../node_modules/mithril/mithril.js"></script>
<script src="../../src/circus.js"></script>
<script src="../../src/model.js"></script>
<script src="../../src/view.js"></script>
<script src="../../src/intent.js"></script>
<script src="../../src/signal.js"></script>
<script src="../../src/composables.js"></script>
<script src="../../libraries/mithril-circus.js"></script>
</head>
<body>
<script>

  /*
  *  Circus.MVI
  *  Application state and logic is completely expressed by and manipulated through
  *  circus signals, arranged as M(odel) V(iew) I(ntent) circuitry that cyclically
  *  feeds the values of each signal into the next.
  *
  *  The direction of information travel is strictly M -> V -> I
  *
  *            +--> Model--+
  *            ^           |  
  *            |           v
  *          Intent  <--  View
  *
  *  The values in the circuit form the application state and are manipulated
  *  through functional composition using map / reduce semantics. For example,
  *  the model will likely map its input onto a different shaped output:
  *
  *     model.map(fn) // where fn: x > y
  *
  *
  *  MODEL: I -> Model -> V
  *  The purpose of the model is to aggregate and map intention signals
  *  onto application model state and pass this data on to the view.
  *  The model is usually the place to tap the current application state 
  *  into the domain. E.g., to save the application state to storage, to call
  *  external services etc.
  */
  var model = circus.signal().map(greet).tap(log)

  function greet(i) {
    return {
      name: i.name || '',
      password: i.password || '',
      salute: i.name && i.password && i.name[0].toUpperCase() + i.name.substr(1) + '!!'
    }
  }

  function log(m) {
    console.log(m.salute)
  }

  /* 
  *  VIEW: M -> View -> I
  *  The view maps the current model state over a render function.
  *  The render function returns a view state suitable for mounting. 
  *  The mounted view feeds the intention signal channel(s) through user actions
  */ 
  var view = circus.signal().map(render)

  function render(model) {
    return m('div', [
      m('h1', 'Please register'),
      m('label',['name', m('input', {
        onchange:m.withAttr('value',intentions.name.value),
        value:model.name
      })]),
      m('label',['password', m('input', {
        type: 'password',
        onchange:m.withAttr('value',intentions.password.value),
        value:model.password
      })]),
      model.salute? m('div',[m('span','Welcome'),m('span',model.salute)]) : ''
    ])
  }

  /*
  *  INTENT: V -> Intent > M
  *  Intentions are signals whose values are generated from user actions and
  *  system events. Most of the application's UI logic is expressed through
  *  intentions that join together to form a circuit that feeds the model.
  */
  var intentions = {
    name: circus.signal(),
    password: circus.signal()
  }

  // use a matcher to ensure that both circuit channels are active
  var intent = circus.signal().join(intentions).and()

  /*
  *  Application: Folds MVI values over time and returns a component suitable 
  *  for mounting.
  */
  var app = circus.fold(model, view, intent)

  /*
  *  Pass the component on to mithril.
  */
  m.module(document.body,app)

</script>
</body>
</html>