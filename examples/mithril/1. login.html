<html>
<head>
<style>
  label {display:block; width:200px;text-align: right;}
  span,input {margin:5px;}
</style>
<script src="../../node_modules/mithril/mithril.js"></script>
<script src="../../src/circus.js"></script>
<script src="../../src/signal.js"></script>
<script src="../../src/circuit.js"></script>
<script src="../../src/mvi.js"></script>
<script src="../../libraries/mithril-circus.js"></script>
</head>
<body>
<script>

  /*
  *  Circus.MVI
  *  Application state and logic is completely expressed by and manipulated through
  *  circus signals, arranged as M(odel) V(iew) I(ntent) circuitry that cyclically
  *  feeds the values of each signal into the next.
  *
  *  The direction of information travel is strictly M -> V -> I
  *
  *            +--> Model--+
  *            ^           |
  *            |           v
  *          Intent  <--  View
  *
  *  The values in the circuit represent the application state and are manipulated
  *  through functional composition using map / reduce semantics. For example,
  *  the model will likely map its input onto a different shaped output:
  *
  *     model.map(fn) // where fn: x > y
  *
  */


  /*
  *  Application: Create a basic mvi circuit exposing model, view and intent circuit points.
  *  In this case, the app also exposes a mithril component suitable for mounting
  */
  var app = circus.mvi()

  /*
  *  MODEL: I -> Model -> V
  *  The purpose of the model is to aggregate and map signalled intentions
  *  onto application state and pass this data on to the view.
  *  The model is usually the place to tap the current state into the domain.
  *  E.g., to save the application state to storage, to call external services etc.
  */
  app.model.map(greet).tap(log)

  function greet(i) {
    return {
      name: i.name || '',
      password: i.password || '',
      salute: i.name && i.password && i.name[0].toUpperCase() + i.name.substr(1) + '!!'
    }
  }

  function log(m) {
    console.log(m.salute)
  }

  /*
  *  VIEW: M -> View -> I
  *  The view maps the current model state over a render function.
  *  The render function returns a view state suitable for mounting.
  *  The mounted view feeds the intention signal channel(s) through user actions
  */
  app.view.map(render)

  function render(model) {
    return m('div',
      model.salute? m('div',[m('span','Welcome'),m('span',model.salute)]) : [
      m('h1', 'Please login'),
      m('label',['name', m('input', {
        onchange:m.withAttr('value',intentions.name.value),
        value:model.name || ''
      })]),
      m('label',['password', m('input', {
        type: 'password',
        onchange:m.withAttr('value',intentions.password.value),
        value:model.password || ''
      })])
    ])
  }

  /*
  *  INTENT: V -> Intent > M
  *  Intentions are signals whose values are generated from user actions and
  *  system events. Most of the application's UI logic is expressed through
  *  intentions that join together to form a circuit that feeds the model.
  */
  var intentions = {
    name: circus.signal(),
    password: circus.signal()
  }

  app.intent.join(intentions)

  /*
  * creating a component with an empty model will start the application and set it to a predictable state:
  */
  m.module(document.body,app.component({}))


</script>
</body>
</html>