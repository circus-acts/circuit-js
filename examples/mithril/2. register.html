<html>
<head>
<style>
  label {display:block; width:250px;text-align: right;}
  span,input {margin:5px;}
</style>
<script src="../../node_modules/mithril/mithril.js"></script>
<script src="../../src/circus.js"></script>
<script src="../../src/signal.js"></script>
<script src="../../src/composables.js"></script>
<script src="../../src/mvi.js"></script>
<script src="../../libraries/mithril-circus.js"></script>
</head>
<body>
<script>

  var debug = function(v) {
    console.log(this.signal.name)
    return v
  }

  // create a new base app and build a circuit on it. Here we are using
  // an MVI pattern.

  var app = circus.mvi(),
      login = app.signal().and('login','user').httpPOST('http://login'),
      register = app.signal().and('register','user','details').httpPOST('/register'),
      specials = app.signal().merge(login,register).httpGET('/specials/:sessionId'),
      // if not registered, pass remaining signal values unconditionally
      notRegistered = app.signal().and({notRegistered:true,'*':undefined})

  //  one signal feeds another signal (group) and awaits their values
  app.model
    .feed(login,register,notRegistered)
    .merge(login,register,specials,notRegistered)

  app.view.map(loginOrRegister)

  function loginOrRegister(state) {
    return m('div', [
      m('h1', 'Please Login'),
      input('Email','email','user'),
      input('Password','password','user','password'),
      !state.notRegistered && [
        button('Log in', 'login'),
        input('Not registered?', 'notRegistered', false, 'checkbox')
      ] || m('div', [
        input('Confirm','confirm',false,'password'),
        dropdown('Title','title',['Mr','Mrs']),
        input('First Name', 'firstName', 'details'),
        input('Last Name', 'lastName', 'details'),
        m('div',[
          'Address',
          input('Line 1','line1', 'details.address'),
          input('Line 2','line2', 'details.address'),
          input('Town','town', 'details.address'),
          input('County','country', 'details.address'),
          input('Country','country', 'details.address')
        ]),
        button('Register','register')
      ])
    ])

    // helpers to build markup and bind state and intentions
    function input(label, name, ns, type) {
      var errorMsg = circus.lens(app.error,name, ns),
          data = circus.lens(state,name,ns),
          intention = circus.lens(intentions,name, ns),
          valueAttr = type === 'checkbox'? 'checked' : 'value',
          action = type === 'checkbox'? 'onchange' : 'onblur',
          attrs = {
            type: type || 'text',
            value:data
          }

      attrs[action] = m.withAttr(valueAttr,intention.value)

      return m('label',[
        label,
        m('input', attrs),
        errorMsg && m('span.error', errorMsg) || ''
      ])
    }
    function button(label,name){
      return m('button', {onclick:app.view.click(circus.lens(intentions,name),true)},[label])
    }
    function dropdown(label, name, data) {
      return m('label',[
        label || name,
        m('select', [
          data.map(function(d){
            return m('option', d)
          })
        ])
      ])
    }
  }

  // construct the intention circuit from signal blocks of named channels.
  // each channel gets its own binding in the view
  var strength = app.signal(),
      password = required().error(strengthTest),
      user = {
        email: required().error(formed),
        password: password
      },
      details = {
        title: required(),
        firstName: required(),
        lastName: required(),
        address: {
          line1: required(),
          line2: app.signal(),
          town: required(),
          county: required(),
          country: required()
        }
      },
      intentions = {
        account: {
          user: user,
          details: details
        }
        strength: strength,
        notRegistered: app.signal().tap(debug),
        confirm: required().error(match),
        login: app.intent.cta(user).take(300)),
        register: app.intent.cta(user,details)
      }

  app.intent.join(intentions)

  app =  {
    account: {
       user = {
        email: required().error(formed),
        password: password
      },
      details = {
        title: required(),
        firstName: required(),
        lastName: required(),
        address: {
          line1: required(),
          line2: app.signal(),
          town: required(),
          county: required(),
          country: required()
        }
      }
    }
  }
        },
        strength: strength,
        notRegistered: app.signal().tap(debug),
        confirm: required().error(match),
        login: app.intent.cta(user).take(300)),
        register: app.intent.cta(user,details)
      }

  // create some helper functions to simplify the circuit definition
  function required(msg) {
    return app.signal().error(function(v){return !v && (msg ||'required')})
  }

  var email = /\S+@\S+\.\S+/i
  function formed(v) {
    return !email.test(v) && 'invalid email'
  }
  function match(v) {
    return v!==password.value() && 'password does not match'
  }
  function strengthTest(v){
    var score = (v || '').length
    strength.value(score)
    return (score < 6) && 'password too weak'
  }

  // kick off by stamping out a copy of the intentions with empty values
  var seed = circus.map(app.intent,function(){return ''})
  // then initialize any of the values
  seed.user.email='m@m.com'
  seed.user.password = '1234'

  m.route(document.body,'/login', {
    '/login': app.component(seed)
  })

</script>
</body>
</html>