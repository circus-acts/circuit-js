<html>
 <head>
  <style>
    label {display:block; width:250px;text-align: right;}
    span,input {margin:5px;}
  </style>

  <script src="../../node_modules/mithril/mithril.js"></script>
  <script src="../../src/signal.js"></script>
  <script src="../../src/circus.js"></script>
  <script src="../../src/circuit.js"></script>
  <script src="../../src/match.js"></script>
  <script src="../../src/composables.js"></script>
  <script src="../../src/mvi.js"></script>
  <script src="../../libraries/mithril-Circus.js"></script>
 </head>
 <body>
 <script>

  var debug = function(v) {
    console.log(this.name)
    return v
  }

  // create a new MVI app exposing model, view and intention signals as properties.
  // The app will extend these signals through appropriate circuitry:
  // - app.model will handle user identity and status
  // - app.view will collect user credential and registration details
  // - app.intent will validate and shape user inputs

  var app = Circus.mvi()

  // Model: I -> M -> V
  // Create
  var login = app.match('logIn').httpPOST('http://login'),
      register = app.match('register').httpPOST('/register'),
      specials = app.merge(login,register).httpGET('/specials/:sessionId')

  // A useful pattern: one signal feeds another signal (group) and awaits their values
  app.model
    .feed(login,register)
    .merge(login,register)
    .join(specials,true)

  // View: M -> V -> I
  app.view.map(loginOrRegister)

  function loginOrRegister(model) {
    return m('div', [
      m('h1', 'Please Login'),
      input('email'),
      input('password'),
      !model.notRegistered && [
        button('logIn'),
        input('notRegistered', 'Not registered?', 'checkbox')
      ] || m('div', [
        input('confirm'),
        dropdown('title',['Mr','Mrs']),
        input('firstName'),
        input('lastName'),
        m('div',[
          'Address',
          input('line1'),
          input('line2'),
          input('town'),
          input('county'),
          input('country')
        ]),
        button('register')
      ])
    ])

    // helpers to build markup and bind model and intentions
    function input(name, label, type) {
      var
          data = Circus.lens(model,name),
          intention = Circus.lens(intentions,name),
          errorMsg = intention.error(),
          valueAttr = type === 'checkbox'? 'checked' : 'value',
          action = type === 'checkbox'? 'onchange' : 'onblur',
          attrs = {
            type: type || 'text',
            value:data
          }

      attrs[action] = m.withAttr(valueAttr,intention.value)
      attrs.placeholder=name;

      return m('label',[
        label || name,
        m('input', attrs),
        errorMsg && m('span.error', errorMsg) || ''
      ])
    }

    function button(name, label){
      return m('button', {onclick:app.view.click(Circus.lens(intentions,name),true)},[label || name])
    }

    function dropdown(name, options, label) {
      return m('label',[
        label || name,
        m('select', [
          options.map(function(d){
            return m('option', d)
          })
        ])
      ])
    }
  }

  // Intent: V -> I -> M
  // construct the intention circuit from signal blocks of named channels.
  // Most of the channels will be fed by view bindings.
  var strength = app.signal(),
      confirm = required().error(match),
      password = required().error(strengthTest),
      user = {
        email: required().error(formed),
        password: password
      },
      details = {
        title: required(),
        firstName: required(),
        lastName: required(),
        address: {
          line1: required(),
          line2: app.signal(),
          town: required(),
          county: required(),
          country: required()
        }
      },
      intentions = {
        account: {
          user: user,
          details: details
        },
        strength: strength,
        notRegistered: app.signal(),
        confirm: confirm,
        logIn: app.intent.cta(user),
        register: app.intent.cta(user,details,confirm, strength)
      }

  app.intent.join(intentions)


  // create some helper functions to simplify the circuit definition
  function required(msg) {
    return app.signal().error(function(v){return !v && (msg ||'required')})
  }

  function formed(v) {
    return !/\S+@\S+\.\S+/i.test(v) && 'invalid email'
  }

  function match(v) {
    return v!==password.value() && 'password does not match'
  }

  function strengthTest(v){
    var score = (v || '').length + (v || '').replace(/[^A-Z0-9]/g, '').length
    strength.value(score)
    return (score < 6) && 'password too weak'
  }

  // App -> run
  // kick off by stamping out a copy of the intentions with empty values
  var seed = Circus.map(app.intent,function(){return ''})
  // ..then initialize any of the values
  seed.account.user.email='m@m.com'
  seed.account.user.password = '123456'
  seed.account.details.title = 'Mr'

  m.module(document.body,  app.component(seed))

 </script>
 </body>
</html>