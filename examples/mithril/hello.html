<html>
<head>
<style>
  label {display:block; width:200px;text-align: right;}
  span,input {margin:5px;}
</style>
<script src="../../node_modules/mithril/mithril.js"></script>
<script src="../../src/circus.js"></script>
<script src="../../src/model.js"></script>
<script src="../../src/view.js"></script>
<script src="../../src/intent.js"></script>
<script src="../../src/signal.js"></script>
<script src="../../src/composables.js"></script>
<script src="../../libraries/mithril-circus.js"></script>
</head>
<body>
<script>

  /*
  *  Circus.MVI
  *  Application state and logic is completely expressed by and manipulated through
  *  circus signals, arranged as M(odel) V(iew) I(ntent) circuitry that cyclically
  *  feed each other values folded over time.
  *
  *  The direction of information travel is strictly M -> V -> I
  *
  *            +--> Model--+
  *            ^           |  
  *            |           v
  *          Intent  <--  View
  *
  *  The values in the circuit form the application state and are manipulated
  *  through functional composition using map / reduce semantics.
  *
  *  MODEL: I -> Model -> V
  *  The purpose of the model is to aggregate and map intention signals
  *  onto application model state and pass this into the view.
  *  The model is usually the place to tap the current application state 
  *  into the domain. E.g., to save the application state to storage, to call
  *  external services etc.
  */
  var model = circus.signal().map(greet)

  function greet(v) {
    return {
      name: v.name,
      password: v.password,
      salute: v.name && v.password && v.name[0].toUpperCase() + v.name.substr(1) + '!!'
    }
  }

  /* 
  *  VIEW: M -> View -> I
  *  Generates the view by applying the current model state to a render
  *  function. The render is a mapping function that takes a model state and 
  *  returns a view state suitable for mounting. The mounted view feeds the 
  *  intention channel(s).
  */ 
  var view = circus.signal().map(render)

  function render(model) {
    return m('div', [
      m('h1', 'Please register'),
      m('label',['name', m('input', {
        onchange:m.withAttr('value',intentions.name.head),
        value:model.name || ''
      })]),
      m('label',['password', m('input', {
        type: 'password',
        onchange:m.withAttr('value',intentions.password.head),
        value:model.password || ''
      })]),
      model.salute? m('div',[m('span','Welcome'),m('span',model.salute)]) : ''
    ])
  }

  /*
  *  INTENT: V -> Intent > M
  *  Intentions are signals whose values are generated from user actions and
  *  system events. Most of the application's UI logic is expressed through
  *  intentions that join together to form a single channel that feeds the model.
  */
  var intentions = {
    name: circus.signal(),
    password: circus.signal()
  }
  var intent = circus.signal().join(intentions)

  /*
  *  Application
  *  Folds MVI values over time and converts it to a component suitable 
  *  for mounting.
  */
  var app = circus.stage(model, view, intent)

  /*
  *  Pass the component on to mithril.
  */
  m.module(document.body,app)

</script>
</body>
</html>